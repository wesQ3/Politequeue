=head1 NAME

Politequeue - A lightweight persistent queue using SQLite

=head1 DESCRIPTION

Politequeue is a lightweight persistent queue using SQLite with an emphasis on simplicity and few dependencies. It has timing metrics for the messages and is easily extendable via SQL.

Tasks/messages are always passed as strings, so you can use JSON data as messages. Messages are interpreted as tasks, so after you C<pop> a message, you need to mark it as done when you finish processing it.

This is a port of polyrand's L<Litequeue|https://github.com/litements/litequeue> from Python to Perl. Included is a UUIDv7 port from L<Steve Simmmons' uuid7|https://github.com/stevesimmons/uuid7>.

=head1 MESSAGES DATA STRUCTURE

=over 4

=item * data (text): the message itself, it must be a string

=item * message_id (text): a UUID v7 generated when the message is put in the queue.

=item * status (int): status of the message. 0 = free, 1 = locked (the message is being processed), 2 = done (the message has been processed, and it can be deleted), 3 = failed.

=item * in_time (int): Unix epoch (nanoseconds) when the message was inserted in the queue

=item * lock_time (int): Unix epoch (nanoseconds) time when the message was locked for processing

=item * done_time (int): Unix epoch (nanoseconds) when the message was marked as done/processed

=back

=head1 ARCHITECTURE

SQLite does not have row-level locks, so we can't use the pattern like C<SELECT ... FOR UPDATE SKIP LOCKED>. The current C<Politequeue> implementation marks a message as locked first and then returns it. The application is in charge of setting it as done. The problem with this approach is that the application could crash while processing the message/task, so it would stay marked locked forever. The messages table has an C<in_time> and C<lock_time> columns (both are Unix epochs). To counter the lock + crash problem, some logic could be implemented like:

    my $time_locked = $in_time - $lock_time;

    if ($time_locked > $threshold) {
        # delete/modify/add_again( $message )
    }

With that pattern, you can check all the tasks that have been locked for more than C<X> seconds and do whatever you need with them.

=head1 EXAMPLES

=head2 Message timing data

We can use the timing data that is automatically created during messages create/lock/mark as done steps.

    my $msg = $q->put("example task");

    # Simulate some processing time
    sleep(1);

    # Pop the message from the queue and mark it as done
    my $popped = $q->pop();
    my $message_id = $popped->{message_id};
    $q->done($message_id);

    # Retrieve timing data for the completed message
    my $done_msg = $q->get($message_id);
    my $in_time   = $done_msg->{in_time} * 1e-9;
    my $lock_time = $done_msg->{lock_time} * 1e-9;
    my $done_time = $done_msg->{done_time} * 1e-9;

    print sprintf(
        "Task %s took %s seconds to get done and was in the queue for %s seconds\n",
        $done_msg->{message_id},
        $done_time - $lock_time,
        $done_time - $in_time
    );

    # Sample output:
    # Task 018d1234-5678-7abc-8def-123456789abc took 0.001 seconds to get done and was in the queue for 1.002 seconds

=head2 C<maxsize> - Maximum queue size

If you specify a C<maxsize> when you initialize the queue, it will create a trigger that will raise an error when that size is reached. In Perl, it will raise a DBI exception.

    my $q = Politequeue->new(filename_or_conn => ":memory:", maxsize => 50);

    for my $i (0..49) {
        $q->put("data_$i");
    }

    die unless $q->qsize() == 50;

An error is raised when the queue has reached its size limit.

    use Try::Tiny;

    try {
        $q->put("new");
    } catch {
        if (/Max queue length reached/i) { # max len reached
            print "Queue is full!\n";
        }
    };

When we C<pop> and item we can add another one. Take into account that C<$q-E<gt>put()> will return the C<rowid> of the latest inserted message, it does B<not> represent the current queue size.

    my $popped = $q->pop();

    # {message => 'aktabyjadzrsohlitnei',
    #  message_id => '08b201c31099a296ef37f23b5257e5b6'}

    # Now we can put another message without error
    $q->put("hello");

    # 51

=head1 METHODS

=head2 new

    my $q = Politequeue->new($filename_or_conn, %options);

Creates a new Politequeue object. With Class::Tiny, this calls BUILD internally.

B<Arguments:>

=over 4

=item * C<filename_or_conn> - Database filename, ":memory:" for in-memory database, or existing DBI database handle

=item * C<memory> - Boolean, set to true to use in-memory database (alternative to ":memory:")

=item * C<maxsize> - Optional integer, maximum number of messages allowed in queue

=item * C<queue_name> - Optional string, name of the table (default: "Queue")

=item * C<sqlite_cache_size_bytes> - Optional integer, SQLite cache size in bytes (default: 256,000)

=back

B<Returns:> Politequeue object

B<Example:>

    my $q = Politequeue->new(filename_or_conn => ":memory:");
    my $q2 = Politequeue->new(filename_or_conn => "queue.db", maxsize => 1000);

=head2 put

    my $message = $q->put($data);

Inserts a new message into the queue.

B<Arguments:>

=over 4

=item * C<$data> - String containing the message data

=back

B<Returns:> Politequeue::Message object containing the inserted message

B<Example:>

    my $message = $q->put("hello world");
    print $message->message_id;  # UUID v7

=head2 pop

    my $message = $q->pop();

Retrieves and locks the next available message from the queue.

B<Arguments:> None

B<Returns:> Politequeue::Message object, or undef if queue is empty

B<Example:>

    my $message = $q->pop();
    if ($message) {
        print "Processing: " . $message->data;
        # ... process message ...
        $q->done($message->message_id);
    }

=head2 peek

    my $message = $q->peek();

Shows the next message that would be returned by pop() without removing it from the queue.

B<Arguments:> None

B<Returns:> Politequeue::Message object, or undef if queue is empty

B<Example:>

    my $next = $q->peek();
    if ($next) {
        print "Next message: " . $next->data;
    }

=head2 get

    my $message = $q->get($message_id);

Retrieves a specific message by its ID.

B<Arguments:>

=over 4

=item * C<$message_id> - String containing the message UUID

=back

B<Returns:> Politequeue::Message object, or undef if not found

B<Example:>

    my $message = $q->get("01234567-89ab-cdef-0123-456789abcdef");
    if ($message) {
        print "Status: " . $message->status;
    }

=head2 done

    my $result = $q->done($message_id);

Marks a message as completed/done.

B<Arguments:>

=over 4

=item * C<$message_id> - String containing the message UUID

=back

B<Returns:> Number of rows affected (usually 1 on success)

B<Example:>

    my $message = $q->pop();
    # ... process the message ...
    $q->done($message->message_id);

=head2 mark_failed

    my $result = $q->mark_failed($message_id);

Marks a message as failed.

B<Arguments:>

=over 4

=item * C<$message_id> - String containing the message UUID

=back

B<Returns:> Number of rows affected (usually 1 on success)

B<Example:>

    my $message = $q->pop();
    eval {
        # ... process the message ...
    };
    if ($@) {
        $q->mark_failed($message->message_id);
    }

=head2 retry

    my $result = $q->retry($message_id);

Marks a locked or failed message as ready again for processing.

B<Arguments:>

=over 4

=item * C<$message_id> - String containing the message UUID

=back

B<Returns:> Number of rows affected (usually 1 on success)

B<Example:>

    my $failed_messages = $q->list_failed();
    for my $msg (@$failed_messages) {
        $q->retry($msg->message_id);
    }

=head2 list_locked

    my $messages = $q->list_locked($threshold_seconds);

Returns all messages that have been locked for longer than the specified threshold.

B<Arguments:>

=over 4

=item * C<$threshold_seconds> - Number of seconds a message must be locked to be included

=back

B<Returns:> Array reference of Politequeue::Message objects

B<Example:>

    # Find messages locked for more than 5 minutes
    my $stuck_messages = $q->list_locked(300);
    for my $msg (@$stuck_messages) {
        warn "Message stuck: " . $msg->message_id;
    }

=head2 list_failed

    my $messages = $q->list_failed();

Returns all messages marked as failed.

B<Arguments:> None

B<Returns:> Array reference of Politequeue::Message objects

B<Example:>

    my $failed = $q->list_failed();
    print "Failed messages: " . scalar(@$failed);

=head2 qsize

    my $size = $q->qsize();

Returns the current size of the queue (excludes done and failed messages).

B<Note:> This ignores the finished items, so the real number of rows in the
SQLite database can be bigger than the number returned.

B<Arguments:> None

B<Returns:> Integer count of active messages

B<Example:>

    print "Queue size: " . $q->qsize();

=head2 empty

    my $is_empty = $q->empty();

Checks if the queue is empty (no ready messages).

B<Arguments:> None

B<Returns:> Boolean (1 if empty, 0 if not empty)

B<Example:>

    if ($q->empty()) {
        print "No work to do\n";
    }

=head2 full

    my $is_full = $q->full();

Checks if the queue is full (only relevant if maxsize was set).

B<Arguments:> None

B<Returns:> Boolean (1 if full, 0 if not full or no maxsize set)

B<Example:>

    unless ($q->full()) {
        $q->put("new message");
    }

=head2 prune

    $q->prune();
    $q->prune($include_failed);

Permanently deletes done messages from the database.

B<Arguments:>

=over 4

=item * C<$include_failed> - Optional boolean, if true also deletes failed messages (default: true)

=back

B<Returns:> Nothing

B<Example:>

    $q->prune();           # Delete done and failed messages
    $q->prune(0);          # Delete only done messages

=head2 vacuum

    $q->vacuum();

Performs a SQLite VACUUM operation to reclaim disk space.

B<Arguments:> None

B<Returns:> Nothing

B<Example:>

    $q->prune();   # Remove deleted messages first
    $q->vacuum();  # Reclaim disk space

=head2 close

    $q->close();

Closes the database connection.

B<Arguments:> None

B<Returns:> Nothing

B<Example:>

    $q->close();

=head2 get_sqlite_version

    my $version = $q->get_sqlite_version();

Returns the minor version number of the SQLite library being used.

B<Arguments:> None

B<Returns:> Integer representing SQLite minor version

B<Example:>

    my $version = $q->get_sqlite_version();
    print "SQLite 3.$version.x\n";

=cut
