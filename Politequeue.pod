=head1 NAME

Politequeue - A lightweight persistent queue using SQLite

=head1 DESCRIPTION

Politequeue is a lightweight persistent queue using SQLite with an emphasis on simplicity and few dependencies. It has timing metrics for the messages and is easily extendable via SQL.

Tasks/messages are always passed as strings, so you can use JSON data as messages. Messages are interpreted as tasks, so after you C<pop> a message, you need to mark it as done when you finish processing it.

This is a port of polyrand's L<Litequeue|https://github.com/litements/litequeue> from Python to Perl. Included is a UUIDv7 port from L<Steve Simmmons' uuid7|https://github.com/stevesimmons/uuid7>.

=head1 MESSAGES DATA STRUCTURE

=over 4

=item * data (text): the message itself, it must be a string

=item * message_id (text): a UUID v7 generated when the message is put in the queue.

=item * status (int): status of the message. 0 = free, 1 = locked (the message is being processed), 2 = done (the message has been processed, and it can be deleted), 3 = failed.

=item * in_time (int): Unix epoch (nanoseconds) when the message was inserted in the queue

=item * lock_time (int): Unix epoch (nanoseconds) time when the message was locked for processing

=item * done_time (int): Unix epoch (nanoseconds) when the message was marked as done/processed

=back

=head1 ARCHITECTURE

SQLite does not have row-level locks, so we can't use the pattern like C<SELECT ... FOR UPDATE SKIP LOCKED>. The current C<Politequeue> implementation marks a message as locked first and then returns it. The application is in charge of setting it as done. The problem with this approach is that the application could crash while processing the message/task, so it would stay marked locked forever. The messages table has an C<in_time> and C<lock_time> columns (both are Unix epochs). To counter the lock + crash problem, some logic could be implemented like:

    my $time_locked = $in_time - $lock_time;
    
    if ($time_locked > $threshold) {
        # delete/modify/add_again( $message )
    }

With that pattern, you can check all the tasks that have been locked for more than C<X> seconds and do whatever you need with them.

=head1 EXAMPLES

Initialize a queue and put 4 messages. Each time you put a message in the queue, it returns the C<rowid> of the message you just inserted.

=head2 Put messages

    use Politequeue;
    
    my $q = Politequeue->new(":memory:");
    
    $q->put("hello");
    $q->put("world");
    $q->put("foo");
    $q->put("bar");
    # 4  <- ID of the last row modified

=head2 Pop messages

Now we can use the C<$q-E<gt>pop()> method to retrieve the next message. For each message, a random C<message_id> will be generated on creation. The C<.pop()> method returns a hash reference with the message's data.

    my $msg = $q->pop();
    # {message => 'hello', message_id => '7da620ac542acd76c806dbcf00218426', ...}

=head2 Printing the queue

The queue object implements stringification, so you can use C<print $q> to check the contents.

    print $q;
    
    # Politequeue(Connection='DBI::sqlite...', items=[{done_time => undef,
    #   in_time => 1612711137,
    #   lock_time => 1612711137,
    #   message => 'hello',
    #   status => 1,
    #   message_id => '7da620ac542acd76c806dbcf00218426'},
    #    ...

=head2 Message processing

If we C<pop> all the messages and try to C<pop> another one, it will return C<undef>.

    # pop remaining
    for (1..3) {
        $q->pop();
    }
    
    die unless !defined $q->pop();

Now we will insert 4 more messages. The last message returns C<8>. That means the last message inserted has a C<rowid> of C<8>. Then we will C<pop()> a message and save it in a variable called C<$task>. The tasks are returned as hash references.

    $q->put("hello");
    $q->put("world");
    $q->put("foo");
    $q->put("bar");
    
    # 8 <- ID of the last row modified
    
    my $task = $q->pop();
    
    die unless $task->{data} eq "hello";

=head2 Peek a message

With the C<$q-E<gt>peek()> method you can have a look at the next message to be processed. The method will return the message, but it won't C<pop> it from the queue. Since we have already popped the C<"hello"> message, the C<peek()> method will return the C<"world"> message.

    my $peeked = $q->peek();
    
    # {message => 'world',
    #  message_id => '44cbc85f12b62891aa596b91f14183e5',
    #  status => 0,
    #  in_time => 1612711138,
    #  lock_time => undef,
    #  done_time => undef}
    
    # next one that is free
    die unless $q->peek()->{message} eq "world";
    
    # status = 0 = free
    die unless $q->peek()->{status} == 0;

Now we'll go back to the message we previously popped from the queue. We will mark it as done with the C<$q-E<gt>done($message_id)> method. After that, we can use the C<$q-E<gt>get($message_id)> method to check it has been marked as done (C<'status' = 2>)

    my ($data, $message_id) = ($task->{data}, $task->{message_id});
    
    # ('hello', 'c9b9ef76e3a77cc66dd749d485613ec1')
    
    $q->done($task->{message_id});
    
    # 8 <- ID of the last row modified
    
    my $msg_info = $q->get($task->{message_id});
    
    # {message => 'hello',
    #  message_id => 'c9b9ef76e3a77cc66dd749d485613ec1',
    #  status => 2,    <---- status is now 2 (DONE)
    #  in_time => 1612711138,
    #  lock_time => 1612711138,
    #  done_time => 1612711138}
    
    my $already_done = $q->get($task->{message_id});
    
    # status = 2 = done
    die unless $already_done->{status} == 2;

=head2 Message timing data

We can use the timing data that is automatically created during messages create/lock/mark as done steps.

    my $in_time = $already_done->{in_time};
    my $lock_time = $already_done->{lock_time};
    my $done_time = $already_done->{done_time} * 1e-9;
    
    print sprintf(
        "Task %s took %s seconds to get done and was in the queue for %s seconds\n",
        $already_done->{message_id},
        $done_time - $lock_time,
        $done_time - $in_time
    );
    
    # Task c9b9ef76e3a77cc66dd749d485613ec1 took 0 seconds to get done and was in the queue for 0 seconds

=head2 Check queue size

We can get the queue size using the C<$q-E<gt>size()> method. It will ignore the finished items, so the real number of rows in the SQLite database can be bigger than the number returned.

To remove the messages marked as done (C<'status' = 2>), use the C<$q-E<gt>prune()> method. This will remove those messages B<permanently>.

    die unless $q->qsize() == 7;
    
    my $next_one_msg = $q->peek()->{message};
    my $next_one_id = $q->peek()->{message_id};
    
    my $task = $q->pop();
    
    die unless $task->{message} eq $next_one_msg;
    die unless $task->{message_id} eq $next_one_id;
    
    # remove finished items
    $q->prune();
    
    print $q;
    
    # Politequeue(Connection='DBI::sqlite...', items=[{done_time => undef,
    #   in_time => 1612711137,
    #   lock_time => 1612711137,
    #   message => 'hello',
    #   status => 1,
    #   message_id => '7da620ac542acd76c806dbcf00218426'},
    #  {done_time => undef,
    #   in_time => 1612711137,
    #   lock_time => 1612711137,
    #   message => 'world',
    #   status => 1,
    #   message_id => 'a593292cfc8d2f3949eab857eafaf608'},
    #  {done_time => undef,
    #   in_time => 1612711137,
    #   lock_time => 1612711137,
    #   message => 'foo',
    #   status => 1,
    #   message_id => '17e843a29770df8438ad72bbcf059bf5'},
    #  ...

=head2 Set a max queue size

If you specify a C<maxsize> when you initialize the queue, it will create a trigger that will raise an error when that size is reached. In Perl, it will raise a DBI exception.

    my $q = Politequeue->new(":memory:", maxsize => 50);
    
    for my $i (0..49) {
        $q->put("data_$i");
    }
    
    die unless $q->qsize() == 50;

An error is raised when the queue has reached its size limit.

    use Try::Tiny;
    
    try {
        $q->put("new");
    } catch {
        if (/integrity/i) { # max len reached
            print "test pass\n";
        }
    };
    
    # test pass

When we C<pop> and item we can add another one. Take into account that C<$q-E<gt>put()> will return the C<rowid> of the latest inserted message, it does B<not> represent the current queue size.

    my $popped = $q->pop();
    
    # {message => 'aktabyjadzrsohlitnei',
    #  message_id => '08b201c31099a296ef37f23b5257e5b6'}
    
    # Now we can put another message without error
    $q->put("hello");
    
    # 51

=head2 Empty queues

We can check if a queue is empty using the C<$q-E<gt>empty()> method.

    # Check if a queue is empty
    die unless $q->empty() == 0; # false
    
    my $q2 = Politequeue->new(":memory:");
    
    die unless $q2->empty() == 1; # true

=head1 DISCLAIMER

I'm still designing the internal structure of Politequeue, the messages metadata and how they are created / locked / deleted, so changes can be expected. However, the main functionality and the exposed API of C<put()> / C<pop()> / C<done()> / C<get()> should stay the same. The changes will be mostly internal or adding new methods to the queue. Feedback is welcome!

=head1 ALTERNATIVES

=over 4

=item * L<Huey|https://github.com/coleifer/huey>: Huey is a task queue implemented in Python, with multiple backends (Redis/SQLite/in-memory). Huey is a more "complete" task queue, it includes a lot of functionality that is missing from C<Politequeue>. The scope of Huey is much bigger, it lets you decorate functions, run tasks periodically, etc. C<Politequeue> tries to "just" be a primitive queue implementation on which to build other tools. Even though it's written in Python, C<Politequeue> is easy to port to other programming languages and have multiple processes interact with the same persistent queue.

=back

=cut
